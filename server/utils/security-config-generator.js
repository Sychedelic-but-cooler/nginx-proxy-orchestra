const { getSetting } = require('../db');
const path = require('path');
const fs = require('fs');

/**
 * Generate rate limit zone definitions for http context
 */
function generateRateLimitZones(db) {
  const rateLimits = db.prepare(`
    SELECT rl.*, ph.domain_names
    FROM rate_limits rl
    JOIN proxy_hosts ph ON rl.proxy_id = ph.id
    WHERE rl.enabled = 1
  `).all();

  if (rateLimits.length === 0) return '';

  let config = '\n# Rate Limiting Zones (Nginx Proxy Orchestra)\n';

  for (const limit of rateLimits) {
    config += `limit_req_zone $binary_remote_addr zone=${limit.zone_name}:10m rate=${limit.rate};\n`;
  }

  return config;
}

/**
 * Generate geo-blocking map for http context
 * Always generates the variable definition to prevent nginx errors
 */
function generateGeoBlockingMap(db) {
  const geoEnabled = getSetting('security_geo_blocking_enabled') === '1';

  const rules = db.prepare(`
    SELECT rule_value, action
    FROM security_rules
    WHERE rule_type = 'geo_block' AND enabled = 1
  `).all();

  // Always define the variable to prevent nginx errors when referenced
  let config = '\n# Geo-Blocking Configuration (Nginx Proxy Orchestra)\n';
  config += 'geo $geo_blocked {\n';
  config += '  default 0;\n';

  if (geoEnabled && rules.length > 0) {
    for (const rule of rules) {
      const value = rule.action === 'deny' ? '1' : '0';
      config += `  ${rule.rule_value} ${value};\n`;
    }
  }

  config += '}\n';

  return config;
}

/**
 * Generate user-agent filtering map
 * Always generates the variable definition to prevent nginx errors
 */
function generateUserAgentMap(db) {
  const uaEnabled = getSetting('security_user_agent_filtering_enabled') === '1';

  const rules = db.prepare(`
    SELECT rule_value
    FROM security_rules
    WHERE rule_type = 'user_agent_filter' AND enabled = 1 AND action = 'deny'
  `).all();

  // Always define the variable to prevent nginx errors when referenced
  let config = '\n# User-Agent Filtering (Nginx Proxy Orchestra)\n';
  config += 'map $http_user_agent $blocked_agent {\n';
  config += '  default 0;\n';

  if (uaEnabled && rules.length > 0) {
    for (const rule of rules) {
      // Support regex patterns
      config += `  ~*${rule.rule_value} 1;\n`;
    }
  }

  config += '}\n';

  return config;
}

/**
 * Generate IP blacklist for http context
 * Always generates the variable definition to prevent nginx errors
 */
function generateIPBlacklistMap(db) {
  const ipEnabled = getSetting('security_ip_blacklist_enabled') === '1';

  const rules = db.prepare(`
    SELECT rule_value
    FROM security_rules
    WHERE rule_type = 'ip_blacklist' AND enabled = 1 AND action = 'deny'
  `).all();

  // Always define the variable to prevent nginx errors when referenced
  let config = '\n# IP Blacklist (Nginx Proxy Orchestra)\n';
  config += 'geo $blocked_ip {\n';
  config += '  default 0;\n';

  if (ipEnabled && rules.length > 0) {
    for (const rule of rules) {
      // Support both single IPs and CIDR ranges
      config += `  ${rule.rule_value} 1;\n`;
    }
  }

  config += '}\n';

  return config;
}

/**
 * Generate complete security configuration for http context
 */
function generateGlobalSecurityConfig(db) {
  const rateLimitZones = generateRateLimitZones(db);
  const geoBlocking = generateGeoBlockingMap(db);
  const userAgentMap = generateUserAgentMap(db);
  const ipBlacklist = generateIPBlacklistMap(db);

  let config = '# Security Configuration - Generated by Nginx Proxy Orchestra\n';
  config += '# Do not edit manually - changes will be overwritten\n';
  config += rateLimitZones + geoBlocking + userAgentMap + ipBlacklist;

  return config;
}

/**
 * Generate security directives for a specific server block
 */
function generateServerSecurityConfig(db, proxyId) {
  let config = '\n  # Security Features\n';

  // IP Blacklist check
  const ipEnabled = getSetting('security_ip_blacklist_enabled') === '1';
  if (ipEnabled) {
    config += '  if ($blocked_ip) {\n';
    config += '    return 403;\n';
    config += '  }\n\n';
  }

  // Geo-blocking
  const geoEnabled = getSetting('security_geo_blocking_enabled') === '1';
  if (geoEnabled) {
    config += '  if ($geo_blocked) {\n';
    config += '    return 403;\n';
    config += '  }\n\n';
  }

  // User-Agent filtering
  const uaEnabled = getSetting('security_user_agent_filtering_enabled') === '1';
  if (uaEnabled) {
    config += '  if ($blocked_agent) {\n';
    config += '    return 403;\n';
    config += '  }\n\n';
  }

  // Rate limiting
  const rateLimit = db.prepare(`
    SELECT * FROM rate_limits
    WHERE proxy_id = ? AND enabled = 1
    LIMIT 1
  `).get(proxyId);

  if (rateLimit) {
    const nodelayStr = rateLimit.nodelay ? ' nodelay' : '';
    config += `  # Rate Limiting: ${rateLimit.rate}\n`;
    config += `  limit_req zone=${rateLimit.zone_name} burst=${rateLimit.burst}${nodelayStr};\n`;
    config += '  limit_req_status 429;\n\n';
  }

  return config;
}

/**
 * Update the global security configuration file
 */
function updateGlobalSecurityConfig(db) {
  const nginxConfigDir = process.env.NGINX_CONFIG_DIR || path.join(__dirname, '../../data/conf');

  // Ensure config directory exists
  if (!fs.existsSync(nginxConfigDir)) {
    fs.mkdirSync(nginxConfigDir, { recursive: true });
  }

  const securityConfigPath = path.join(nginxConfigDir, 'security-global.conf');
  const securityConfig = generateGlobalSecurityConfig(db);

  fs.writeFileSync(securityConfigPath, securityConfig, 'utf8');
  console.log(`âœ“ Updated global security config: ${securityConfigPath}`);

  return securityConfigPath;
}

module.exports = {
  generateRateLimitZones,
  generateGeoBlockingMap,
  generateUserAgentMap,
  generateIPBlacklistMap,
  generateGlobalSecurityConfig,
  generateServerSecurityConfig,
  updateGlobalSecurityConfig
};
