/**
 * Module File Manager
 *
 * Manages nginx module configuration files in data/modules directory.
 * Instead of inserting module content line-by-line into proxy configs,
 * modules are saved as separate .conf files and included using nginx's include directive.
 */

const fs = require('fs');
const path = require('path');

/**
 * Get the modules directory path
 */
function getModulesDir() {
  if (process.env.NGINX_MODULES_DIR) {
    return process.env.NGINX_MODULES_DIR;
  }
  // Default to data/modules in project root
  return path.join(__dirname, '../../data/modules');
}

/**
 * Sanitize module name for use as filename
 * Converts module name to safe filename format
 * @param {string} name - The module name
 * @returns {string} - Safe filename (without .conf extension)
 */
function sanitizeModuleName(name) {
  if (!name) {
    return `module_${Date.now()}`;
  }

  // Convert to lowercase and replace spaces/special chars with hyphens
  let sanitized = name.toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')  // Replace non-alphanumeric with hyphens
    .replace(/^-+|-+$/g, '');      // Remove leading/trailing hyphens

  // Limit length to 100 characters
  sanitized = sanitized.substring(0, 100);

  // If empty after sanitization, use timestamp
  if (!sanitized) {
    sanitized = `module_${Date.now()}`;
  }

  return sanitized;
}

/**
 * Generate module configuration file
 * Creates a .conf file in data/modules with proper formatting and comments
 * @param {Object} module - Module object with id, name, description, content, level
 * @returns {string} - Path to the generated file
 */
function generateModuleFile(module) {
  const modulesDir = getModulesDir();

  // Create directory if it doesn't exist
  if (!fs.existsSync(modulesDir)) {
    console.log(`Creating modules directory: ${modulesDir}`);
    fs.mkdirSync(modulesDir, { recursive: true });
  }

  const filename = `${sanitizeModuleName(module.name)}.conf`;
  const filePath = path.join(modulesDir, filename);

  // Generate file content with proper formatting and comments
  let content = `# ═══════════════════════════════════════════════════════════════════\n`;
  content += `# Module: ${module.name}\n`;
  content += `# Level: ${module.level || 'location'}\n`;
  if (module.description) {
    content += `# Description: ${module.description}\n`;
  }
  content += `# Generated by Nginx Proxy Orchestra\n`;
  content += `# Module ID: ${module.id}\n`;
  content += `# ═══════════════════════════════════════════════════════════════════\n\n`;

  // Add the actual module content
  // Content should already be properly formatted from the database
  content += module.content.trim();
  content += `\n`;

  // Write the file
  fs.writeFileSync(filePath, content, 'utf8');
  console.log(`Generated module file: ${filePath}`);

  return filePath;
}

/**
 * Delete module configuration file
 * @param {string} moduleName - The module name
 * @returns {boolean} - True if deleted, false if not found
 */
function deleteModuleFile(moduleName) {
  const modulesDir = getModulesDir();
  const filename = `${sanitizeModuleName(moduleName)}.conf`;
  const filePath = path.join(modulesDir, filename);

  if (fs.existsSync(filePath)) {
    // Create backup before deleting
    const backupPath = `${filePath}.deleted.${Date.now()}`;
    fs.renameSync(filePath, backupPath);
    console.log(`Deleted module file: ${filePath} (backed up to ${backupPath})`);
    return true;
  }

  return false;
}

/**
 * Get the include path for a module (relative or absolute based on config)
 * @param {string} moduleName - The module name
 * @returns {string} - Path to use in nginx include directive
 */
function getModuleIncludePath(moduleName) {
  const modulesDir = getModulesDir();
  const filename = `${sanitizeModuleName(moduleName)}.conf`;
  return path.join(modulesDir, filename);
}

/**
 * Regenerate all module files from database
 * Useful for migrations or repairs
 * @param {Object} db - Database instance
 * @returns {number} - Number of files generated
 */
function regenerateAllModuleFiles(db) {
  console.log('Regenerating all module files...');
  
  const modules = db.prepare('SELECT * FROM modules').all();
  let count = 0;

  for (const module of modules) {
    try {
      generateModuleFile(module);
      count++;
    } catch (error) {
      console.error(`Error generating file for module ${module.name}:`, error.message);
    }
  }

  console.log(`Successfully regenerated ${count} module files`);
  return count;
}

/**
 * Clean up old deleted module files (older than specified days)
 * @param {number} daysOld - Delete files older than this many days (default 7)
 */
function cleanupDeletedModuleFiles(daysOld = 7) {
  const modulesDir = getModulesDir();
  const cutoffTime = Date.now() - (daysOld * 24 * 60 * 60 * 1000);

  if (!fs.existsSync(modulesDir)) {
    return;
  }

  try {
    const allFiles = fs.readdirSync(modulesDir);
    const deletedFiles = allFiles.filter(file => file.includes('.deleted.'));

    deletedFiles.forEach(file => {
      const fullPath = path.join(modulesDir, file);
      const stats = fs.statSync(fullPath);

      if (stats.mtime.getTime() < cutoffTime) {
        try {
          fs.unlinkSync(fullPath);
          console.log(`Cleaned up old deleted module file: ${file}`);
        } catch (err) {
          console.error(`Failed to delete ${file}:`, err.message);
        }
      }
    });
  } catch (error) {
    console.error('Error cleaning up deleted module files:', error.message);
  }
}

module.exports = {
  getModulesDir,
  sanitizeModuleName,
  generateModuleFile,
  deleteModuleFile,
  getModuleIncludePath,
  regenerateAllModuleFiles,
  cleanupDeletedModuleFiles
};
