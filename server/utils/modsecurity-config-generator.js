/**
 * ModSecurity Configuration Generator
 *
 * Generates ModSecurity configurations for WAF profiles and integrates
 * them into nginx server blocks.
 */

const { getSetting } = require('../db');
const path = require('path');
const fs = require('fs');

const MODSEC_DIR = '/etc/nginx/modsec';
const PROFILES_DIR = path.join(__dirname, '../../data/modsec-profiles');
const DATA_DIR = path.join(__dirname, '../../data');

/**
 * Ensure required directories exist
 */
function ensureDirectories() {
  if (!fs.existsSync(PROFILES_DIR)) {
    fs.mkdirSync(PROFILES_DIR, { recursive: true });
  }
  if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
  }
}

/**
 * Generate main ModSecurity configuration
 * This is included in all nginx server blocks with WAF enabled
 */
function generateMainModSecConfig() {
  const wafEnabled = getSetting('waf_enabled') === '1';
  const wafMode = getSetting('waf_mode') || 'detection';
  const projectRoot = path.join(__dirname, '../..');
  const auditLogPath = getSetting('waf_audit_log_path') || path.join(projectRoot, 'logs/waf/audit.log');
  const debugLogPath = getSetting('waf_debug_log_path') || path.join(projectRoot, 'logs/waf/debug.log');
  const requestBodyLimit = getSetting('waf_request_body_limit') || '13107200';  // 12.5MB
  const responseBodyLimit = getSetting('waf_response_body_limit') || '524288';   // 512KB

  if (!wafEnabled) {
    // Return minimal config if WAF is disabled
    return `# ModSecurity - DISABLED\nSecRuleEngine Off\n`;
  }

  let config = `# ModSecurity Main Configuration
# Generated by Nginx Proxy Orchestra
# DO NOT EDIT MANUALLY - Changes will be overwritten

# ═══════════════════════════════════════════════════════════
# Core Configuration
# ═══════════════════════════════════════════════════════════

# SecRuleEngine is set per-profile, not here
# Each WAF profile defines its own rule engine mode (DetectionOnly/On/Off)

# ═══════════════════════════════════════════════════════════
# Request Body Handling
# ═══════════════════════════════════════════════════════════

SecRequestBodyAccess On
SecRequestBodyLimit ${requestBodyLimit}
SecRequestBodyNoFilesLimit 131072
SecRequestBodyLimitAction Reject

# ═══════════════════════════════════════════════════════════
# Response Body Handling
# ═══════════════════════════════════════════════════════════

SecResponseBodyAccess On
SecResponseBodyMimeType text/plain text/html text/xml application/json application/javascript
SecResponseBodyLimit ${responseBodyLimit}
SecResponseBodyLimitAction ProcessPartial

# ═══════════════════════════════════════════════════════════
# Audit Logging
# ═══════════════════════════════════════════════════════════

SecAuditEngine RelevantOnly
SecAuditLogRelevantStatus "^(?:5|4(?!04))"
SecAuditLogParts ABIJDEFHZ
SecAuditLogType Serial
SecAuditLog ${auditLogPath}
SecAuditLogFormat JSON

# ═══════════════════════════════════════════════════════════
# Debug Logging
# ═══════════════════════════════════════════════════════════

SecDebugLog ${debugLogPath}
SecDebugLogLevel 0

# ═══════════════════════════════════════════════════════════
# File Handling
# ═══════════════════════════════════════════════════════════

SecTmpDir /tmp
SecDataDir /tmp
SecUploadDir /tmp
SecUploadKeepFiles Off
SecUploadFileMode 0600

# ═══════════════════════════════════════════════════════════
# Miscellaneous
# ═══════════════════════════════════════════════════════════

SecArgumentSeparator &
SecCookieFormat 0
# SecServerSignature not supported in ModSecurity v3
SecStatusEngine On
SecCollectionTimeout 600
SecPcreMatchLimit 250000
SecPcreMatchLimitRecursion 250000

# ═══════════════════════════════════════════════════════════
# Character Encoding
# ═══════════════════════════════════════════════════════════

# SecUnicodeMapFile not needed for ModSecurity v3
# SecDefaultAction is set by CRS crs-setup.conf, not here

# ═══════════════════════════════════════════════════════════
# OWASP Core Rule Set
# ═══════════════════════════════════════════════════════════

Include ${MODSEC_DIR}/crs-setup.conf
Include ${MODSEC_DIR}/rules/*.conf

# ═══════════════════════════════════════════════════════════
# Profile-Specific Rules
# ═══════════════════════════════════════════════════════════
# Each nginx proxy loads its own profile config via modsecurity_rules_file
# DO NOT include profiles here (causes SecRuleEngine conflicts)
`;

  return config;
}

/**
 * Generate WAF profile-specific configuration
 * This includes paranoia level, anomaly thresholds, and rule group toggles
 */
function generateProfileConfig(profile) {
  const config_data = JSON.parse(profile.config_json || '{}');
  const paranoiaLevel = profile.paranoia_level || 1;
  const anomalyInbound = config_data.anomaly_threshold_inbound || 5;
  const anomalyOutbound = config_data.anomaly_threshold_outbound || 4;
  const ruleGroups = config_data.rule_groups || {};
  const ruleEngineMode = config_data.rule_engine_mode || 'DetectionOnly';

  let config = `# ═══════════════════════════════════════════════════════════
# WAF Profile: ${profile.name}
# ${profile.description}
# Generated by Nginx Proxy Orchestra
# ═══════════════════════════════════════════════════════════

# ═══════════════════════════════════════════════════════════
# Rule Engine Mode: ${ruleEngineMode}
# ═══════════════════════════════════════════════════════════
# DetectionOnly = Detect and log attacks, but don't block
# On = Actively block malicious requests
# Off = Disable ModSecurity entirely

SecRuleEngine ${ruleEngineMode}

# ═══════════════════════════════════════════════════════════
# Paranoia Level: ${paranoiaLevel}
# ═══════════════════════════════════════════════════════════
# Higher levels = more rules, more false positives
# Level 1 (Default): Recommended for most applications
# Level 2: Additional checks for sensitive applications
# Level 3: Strict checking (expect false positives)
# Level 4: Very strict (only for testing)

SecAction \\
  "id:900000,\\
   phase:1,\\
   nolog,\\
   pass,\\
   t:none,\\
   setvar:tx.paranoia_level=${paranoiaLevel}"

# ═══════════════════════════════════════════════════════════
# Anomaly Scoring Thresholds
# ═══════════════════════════════════════════════════════════

# Inbound threshold: ${anomalyInbound}
# Outbound threshold: ${anomalyOutbound}
# Lower values = more strict blocking

SecAction \\
  "id:900110,\\
   phase:1,\\
   nolog,\\
   pass,\\
   t:none,\\
   setvar:tx.inbound_anomaly_score_threshold=${anomalyInbound},\\
   setvar:tx.outbound_anomaly_score_threshold=${anomalyOutbound}"

# ═══════════════════════════════════════════════════════════
# Rule Group Configuration
# ═══════════════════════════════════════════════════════════

`;

  // Rule group descriptions
  const ruleGroupInfo = {
    sql_injection: { id: '942000-942999', name: 'SQL Injection Protection' },
    xss: { id: '941000-941999', name: 'Cross-Site Scripting (XSS) Protection' },
    rce: { id: '932000-932999', name: 'Remote Code Execution (RCE) Protection' },
    lfi: { id: '930000-930999', name: 'Local File Inclusion (LFI) Protection' },
    rfi: { id: '931000-931999', name: 'Remote File Inclusion (RFI) Protection' },
    php_injection: { id: '933000-933999', name: 'PHP Code Injection Protection' },
    java_injection: { id: '944000-944999', name: 'Java Code Injection Protection' },
    session_fixation: { id: '943000-943999', name: 'Session Fixation Protection' },
    multipart_attack: { id: '922000-922999', name: 'Multipart/Form-Data Attack Protection' },
    generic_attack: { id: '934000-934999', name: 'Generic Application Attack Protection' },
    protocol_attack: { id: '920000-920999', name: 'Protocol Attack Protection' },
    protocol_enforcement: { id: '921000-921999', name: 'Protocol Enforcement' },
    request_limits: { id: '960000-960999', name: 'Request Limits' },
    scanner_detection: { id: '913000-913999', name: 'Scanner Detection' }
  };

  // Disable rule groups that are explicitly set to false
  Object.keys(ruleGroupInfo).forEach(key => {
    if (ruleGroups[key] === false) {
      const info = ruleGroupInfo[key];
      config += `# DISABLED: ${info.name}\n`;
      config += `SecRuleRemoveById ${info.id}\n\n`;
    }
  });

  // Custom rule exclusions for this profile
  config += `# ═══════════════════════════════════════════════════════════\n`;
  config += `# Custom Rule Exclusions\n`;
  config += `# (Managed via web UI)\n`;
  config += `# ═══════════════════════════════════════════════════════════\n\n`;

  // Placeholder for custom exclusions (will be populated by exclusion system)
  config += `# Add custom exclusions here via the web UI\n\n`;

  return config;
}

/**
 * Generate per-proxy WAF directives for nginx server block
 * This is injected into the nginx server {} block
 */
function generateProxyWAFConfig(db, proxyId) {
  const wafEnabled = getSetting('waf_enabled') === '1';

  if (!wafEnabled) {
    return '';
  }

  // Check if this proxy has a WAF profile assigned (single profile model)
  const proxy = db.prepare(`
    SELECT waf_profile_id FROM proxy_hosts WHERE id = ?
  `).get(proxyId);

  if (!proxy || !proxy.waf_profile_id) {
    return '';
  }

  // Get the profile
  const profile = db.prepare(`
    SELECT * FROM waf_profiles WHERE id = ? AND enabled = 1
  `).get(proxy.waf_profile_id);

  if (!profile) {
    return '';
  }

  // Parse profile config_json to get rule_engine_mode
  const config_data = JSON.parse(profile.config_json || '{}');
  const ruleEngineMode = config_data.rule_engine_mode || 'DetectionOnly';

  // Generate nginx directives
  let config = `\n  # ═════════════════════════════════════════════════════\n`;
  config += `  # WAF Protection: ${profile.name}\n`;
  config += `  # Paranoia Level: ${profile.paranoia_level}\n`;
  config += `  # Rule Engine Mode: ${ruleEngineMode}\n`;
  config += `  # ═════════════════════════════════════════════════════\n\n`;

  // Enable ModSecurity
  config += `  modsecurity on;\n`;
  config += `  modsecurity_rules_file ${MODSEC_DIR}/main.conf;\n`;

  // Include profile-specific rules (contains SecRuleEngine directive)
  const profilePath = path.join(PROFILES_DIR, `profile_${profile.id}.conf`);
  config += `  modsecurity_rules_file ${profilePath};\n`;

  // Always include exclusion file (created for all profiles, even if empty)
  const exclusionPath = path.join(PROFILES_DIR, `exclusions_profile_${profile.id}.conf`);
  config += `  modsecurity_rules_file ${exclusionPath};\n`;

  config += `\n`;

  return config;
}

/**
 * Get WAF exclusions for a specific profile
 */
function getProfileExclusions(db, profileId) {
  try {
    return db.prepare(`
      SELECT * FROM waf_exclusions
      WHERE profile_id = ? AND enabled = 1
      ORDER BY created_at
    `).all(profileId);
  } catch (error) {
    console.error('Error getting profile exclusions:', error);
    return [];
  }
}

/**
 * Generate exclusion configuration file
 */
function generateExclusionConfig(exclusions, outputPath) {
  let config = `# WAF Exclusions Configuration\n`;
  config += `# Generated by Nginx Proxy Orchestra\n`;
  config += `# These rules exclude specific patterns from WAF checks\n\n`;

  if (exclusions.length === 0) {
    config += `# No exclusions configured for this profile\n`;
    config += `# Exclusions can be added via the web UI when false positives are detected\n\n`;
  }

  for (const exclusion of exclusions) {
    config += `# Exclusion: ${exclusion.reason || 'No reason provided'}\n`;
    config += `# Created: ${exclusion.created_at}\n`;

    if (exclusion.path_pattern && exclusion.parameter_name) {
      // Exclude specific parameter on specific path
      config += `SecRuleUpdateTargetById ${exclusion.rule_id} "!REQUEST_COOKIES:${exclusion.parameter_name}" \\
  "chain,id:${900000 + exclusion.id}"\n`;
      config += `  SecRule REQUEST_URI "@beginsWith ${exclusion.path_pattern}"\n\n`;
    } else if (exclusion.path_pattern) {
      // Exclude rule on specific path
      config += `SecRule REQUEST_URI "@beginsWith ${exclusion.path_pattern}" \\
  "id:${900000 + exclusion.id},phase:1,pass,ctl:ruleRemoveById=${exclusion.rule_id}"\n\n`;
    } else if (exclusion.parameter_name) {
      // Exclude specific parameter globally
      config += `SecRuleUpdateTargetById ${exclusion.rule_id} "!REQUEST_COOKIES:${exclusion.parameter_name}"\n\n`;
    } else {
      // Disable rule entirely (use with caution!)
      config += `SecRuleRemoveById ${exclusion.rule_id}\n\n`;
    }
  }

  fs.writeFileSync(outputPath, config, 'utf8');
}

/**
 * Update all WAF configurations
 * Called when profiles are created/updated or settings changed
 */
function updateWAFConfigurations(db) {
  try {
    console.log('Updating WAF configurations...');

    // Ensure directories exist
    ensureDirectories();

    // Generate main ModSecurity config
    const mainConfig = generateMainModSecConfig();
    const mainConfigPath = path.join(MODSEC_DIR, 'main.conf');

    fs.writeFileSync(mainConfigPath, mainConfig, 'utf8');
    console.log(`✓ Updated main ModSecurity config: ${mainConfigPath}`);

    // Generate all profile configs AND exclusion files
    const profiles = db.prepare('SELECT * FROM waf_profiles WHERE enabled = 1').all();

    for (const profile of profiles) {
      // Generate profile config
      const profileConfig = generateProfileConfig(profile);
      const profilePath = path.join(PROFILES_DIR, `profile_${profile.id}.conf`);
      fs.writeFileSync(profilePath, profileConfig, 'utf8');
      console.log(`✓ Generated profile config: ${profilePath}`);

      // Generate exclusion file (always, even if empty)
      const exclusions = getProfileExclusions(db, profile.id);
      const exclusionPath = path.join(PROFILES_DIR, `exclusions_profile_${profile.id}.conf`);
      generateExclusionConfig(exclusions, exclusionPath);
      console.log(`✓ Generated exclusion file: ${exclusionPath} (${exclusions.length} rules)`);
    }

    return true;
  } catch (error) {
    console.error('Error updating WAF configurations:', error);
    return false;
  }
}

/**
 * Check if ModSecurity is installed and available
 */
function checkModSecurityInstalled() {
  // Check if main.conf exists
  const mainConfPath = path.join(MODSEC_DIR, 'main.conf');
  const crsPath = path.join(MODSEC_DIR, 'crs-setup.conf');

  return {
    mainConfExists: fs.existsSync(mainConfPath),
    crsInstalled: fs.existsSync(crsPath),
    modsecDirExists: fs.existsSync(MODSEC_DIR)
  };
}

module.exports = {
  generateMainModSecConfig,
  generateProfileConfig,
  generateProxyWAFConfig,
  updateWAFConfigurations,
  checkModSecurityInstalled,
  getProfileExclusions,
  generateExclusionConfig
};
